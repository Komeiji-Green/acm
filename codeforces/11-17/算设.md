## 领域综述：计算几何&数据结构

### 简介

​		作为计算机科学的一个分支，计算几何主要研究解决几何问题中的算法。最常见的如凸包（convex hull）、最小圆覆盖等算法，还有相交测试、碰撞检测等问题。计算几何还研究许多几何空间中的数据结构问题，如区域查询（range searching：查询一个区域内包含的所有点）和矩形覆盖查询（rectangle stabbing：查询包含单点的所有矩形区域）这两大基本问题。这些问题及其解决方案在游戏引擎、地理信息系统（GIS）的开发中有着实际的应用。

​		下面将以基本数据结构和基本问题两个角度来介绍计算几何与数据结构的交叉领域，最后引出将要介绍的文章。

### 基本数据结构：线段树/区间树

​		线段树（区间树）是解决一维区间查询问题的利器。在对一维点集（一般是整点）建立线段树后，我们就可以在$O(\log n)$的时间复杂度内进行区间查询、单点修改、区间修改等操作。比如查询区间内元素之和（区间查询）、改变某一点处元素的值（单点修改），将区间中元素统一修改为给定值$c_0$（区间修改）。

​		其中，线段树所维护的区间信息一定是可合并的，如区间元素的个数，区间元素和，区间最值等，总之，任何一个区间的信息都可以通过其子区间信息快速合并而得。基于这样的思路，我们可以用分治策略建立线段树：

​		首先，用结点代表一个区间$[l,r]$，如果这个区间长度为1，则该结点作为叶子结点返回，否则将区间二分为两个子区间$[l, m]$和$[m+1,r]$，其中$m=(l+r)/2$，并将它们赋给左右子结点，对子结点递归执行此操作。

​		那么，如果我们对整体区间$[1,n]$建立线段树，就可以得到一颗二叉树，每个结点维护区间$[l,r]$中的信息，且其左右子结点维护$[l,m]$和$[m+1,r]$的信息。这颗树总共有n个叶子结点，对应所有长度为1的区间，又注意到它是一颗2-正则树，即所有结点要么为叶结点，要么有两个儿子，于是总结点数为$2n-1$，空间复杂度为$O(n)$。

​		线段树的一些基本操作，如区间修改、单点查询等，时间复杂度都是$O(\log n)$，且很容易实现。

​		区间查询：假如我们想查询的是区间和，只需要通过以下算法实现（C++描述）：

```c++
// k 是当前线段树结点的标号
// [l, r] 是当前线段树结点所对应的区间
// 这里采用二叉树的顺序存储，于是子结点下标可以通过计算得到，同时子结点所维护区间也可以从当前区间二分得到。t[k]存储区间和。
int query(int L, int R, int k, int l, int r) {
    if(L <= l && r <= R) // 如果当前区间包含于待查询区间，则直接返回其贡献 
        return t[k]; 
    else { // 否则应当向下二分以找到待查区间边界。
        Pushdown(k);
        int m = (l + r) / 2;
        int ans = 0;
        if(L <= m)
            ans += query(L, R, 2 * k, l, m);
        if(R > m) 
            ans += query(L, R, 2 * k + 1, m + 1, r); 
        return ans;
    }
}`
```

​		![image-20210112213339563](C:\Users\pc\AppData\Roaming\Typora\typora-user-images\image-20210112213339563.png)		对区间查询过程的分析有助于我们更好地理解线段树，按照上述C++代码执行算法流程，我们相当于先二分找到区间的左边界，再从左到右依次跳过一些完全包含于待查区间的子区间，最后二分找到区间的右边界，把我们经过的所有区间累加起来，即可不重不漏地统计待查区间中的所有答案。

​		上图展示了区间查询的过程，其中黑点为不包含于待查区间的结点，而绿色的子树则代表着那些被直接跳过的完全包含于待查区间的子区间，不难发现，时间复杂度完全取决于黑点的数量。从上而下，一开始黑色结点所对应的区间必定既包含左边界、也包含右边界，直到某一时刻，当分割点$m\in[L,R]$时，子区间必将只能包含左、右边界中的某一个，于是黑色结点出现分叉，这两个分叉其实都是对边界的二分查找过程。因为同一层至多出现两个黑色结点，而线段树的高度显然为$O(\log n)$，于是查询的时间复杂度为$O(\log n)$。

​		单点修改：如果我们想修改单点处的值，只需要先二分找到点的位置修改，然后在回溯的过程中更新所有祖先节点的信息（pushup）即可，时间复杂度为$O(\log n)$，C++实现如下：

```c++
void Pushup(int k) { // 将子结点信息合并到结点k上
    t[k] = t[k*2] + t[k*2+1];
}
void add(int idx, int v, int k, int l, int r) {
    if(l == r) {	// 寻找到叶子节点后，修改信息为v
        t[k] = v;
    } else {
        int m = (l + r) / 2;
        if(idx <= m)
            add(idx, v, k*2, l, m); 
        else 
            add(idx, v, k*2+1, m + 1, r);
        Pushup(k); // 在回溯过程中调用pushup，将已修改的结点信息合并到父结点上，保证各结点均存储正确的信息
    }
}
```
​		

​		可以见得，线段树能够很好地解决一维区间信息的动态查询问题，那么如何处理二维或n维区间的动态查询？其实，这就是计算几何-数据结构领域（Geometric Data Structures）中的一类经典问题——正交区间查询（orthogonal range reporting）问题的高维形态，不论是二维/三维还是多维形态，在学术界中都已经给出了成熟的解法，但在这里我们将介绍一种利用高维形态的线段树的朴素做法，以引出我们的下一个基本数据结构——“树套树”。

### 基本数据结构：树套树（线段树的高维推广）

​		假设我们现在要维护二维平面上的信息，要求能够动态查询任意矩形方区中的元素之和，如何实现？

​		回想线段树的区间查询，我们会经过总共$O(\log n)$个完全位于待查区间$[L, R]$中的结点，并返回储存在其上的子区间和，这些子区间和的累加即为答案。此时，所有子区间和都是直接存储在结点上并$O(1)$返回的，事实上，结点并不仅仅只能存储一个值，事实上它完全可以存储一个数据结构，也完全可以是另一个线段树。

​		这就启发我们将线段树“套起来”以维护二维信息，具体来说，外层线段树维护$x$维度的信息，对于它的每一个结点$v$，记其所代表的区间为$[l,r]$，我们对平面中所有$x$坐标落在$[l,r]$中的点按$y$坐标建立一个内层线段树，并把它们的根节点记录在$v$中。

​		查询方式：假设我们要查询矩形$[a,b;c,d]$，可以先在外层线段树上查询区间$[a,b]$，对那些完全包含于$[a,b]$的子结点，再在其对应的内层线段树上查询$[c,d]$的区间和，最后将答案累加，就得到了矩形所对应的和。

​		时间复杂度：假设$x,y$的范围都是$[1,n]$，那么查询时间复杂度显然是$O(\log^2n)$的，而空间复杂度，观察外层线段树，每个结点$[l,r]$维护一个内层线段树，需要$O(r-l)$的空间，而线段树同一层的结点不会有交集，故各层所需空间均不超过$O(n)$，又线段树高度为$O(\log n)$，于是空间复杂度$O(n\log n)$。

​		总而言之，略去细节，树套树可以这样递归表述：
​		1.第$1$层线段树按最后一个维度建立，每个结点均存储一个n维立方体所对应的信息。
​		2.第$i$层线段树按倒数第$i$维建立，各个结点均维护一个第$i-1$层线段树。
​		这种将基础数据结构通过递归套用来构造新数据结构的方法十分重要，在原文最核心定理的证明中会有所体现。



### 基本问题：分散层叠问题

​		分散层叠（Fractional Cascading），准确来说是一种算法，但它一开始的提出是为了解决这样的一个问题：我们有$k$个有序集，这些集合总共有$n$个元素，每次查询一个值$q$，要求返回$q$在这$k$个有序集中的前驱。

​		这还不简单？我们对每个有序集排好序，然后做$k$次二分查找，时间复杂度是$O(k\log n)$。但如果我们要求的查询复杂度是$O(k+\log n)$呢，因为在面临对大量集合的查询时，我们最希望的是算法运行时间与输出答案的时间基本相当，这才达到了最优。

​		对于这个问题，在1986年，Chazelle和Guibas已经给出了一种解法，名为“分散层叠”，它维护一个使用线性空间的数据结构，最终取得$O(\log n + |\pi|)$的查询时间复杂度，具体实现这里不详细展开，我们在这里更关心分散层叠的推广形式。

​		目前，这$k$个集合都是共同查询的，但有时我们只想查询其中的部分集合，注意这部分集合必定是具有某种逻辑关系的，不然我们也就只能使用朴素解法了。

​		所以，分散层叠的一种推广形式是，k个集合形成某种逻辑结构（比如链、树、图等），我们对其中的部分集合$\pi$进行查询，其中$\pi$可为链上的某组连续结点，树上的路径/子树，或图的一个连通子图等，目标是返回$q$在$\pi$的各个集合中的前驱。对于这种推广形式，学术界已经得到了优秀的解法。

​		再考虑另一种推广形式：有序集本质上是一个直线，我们的查询就对应着直线上的一个点，而寻找该点的前驱就等同于确定这个点在直线的哪个区域（区间）当中。所以我们可以考虑二维推广，即我们的集合是一个平面图，查询点$q$为一个二维平面上的点，目标是输出平面图中包含$q$的面。

​		将以上两种推广形式综合起来，我们是否可以得到一个优秀的解法呢？很遗憾，答案是否定的，在2001年的STOC上，Chazelle和Liu证明了“二维分散层叠”的空间复杂度下界为平方级别，且最坏情况的构造甚至特别简单，这使学界确信分散层叠本质上只是一个在一维空间上的算法，而无法进行高维推广。

​		不过，二维分散层叠这条路并未被完全堵死。在2020年的FOCS上，Peyman Afshani 和 Pingan Cheng 的研究表明，对于“轴对齐”的二维分散层叠问题，即所有平面图的边均平行于x轴或y轴，的确可以突破Chazelle和Liu给出的下界，取得一个比较优秀的时间空间复杂度。接下来就将介绍这篇文章。

## 论文阅读报告

### 摘要

​		分散层叠（Fractional Cascading）是数据结构领域中的一个重要且富有影响力的算法，它能够解决一类重要的问题——遍历搜索问题（iterative search problem）。问题的描述为：输入一个常数阶的图G，以及对G的各结点赋上一个有序集合，我们想要预处理图G，使得当查询值q以及连通子图$\pi$时，可以高效地找出q在$\pi$上所有结点对应的有序集合中的前驱。对于这个问题，Chazelle和Guibas已经给出了基本结论，即存在一个使用线性空间的数据结构，取得$O(\log n + |\pi|)$的查询时间复杂度，因为要输出答案，这种复杂度已经达到最优。在这个算法已经广为人知后，在2001年的STOC上，Chazelle和Liu证明了“二维分散层叠”的几乎平方级别的空间复杂度下界，这使学界确信分散层叠本质上只是一个在一维空间上的算法，而无法进行推广。

​		在二维分散层叠问题中，对于图G的每一个结点，我们赋上一个平面剖分（planar subdivision，即所有边都为直线段的平面图），并且查询变为一个平面上的点q与连通子图$\pi$，我们希望在$\pi$所包含的所有平面剖分中找到q的定位（即平面图中包含q的面）。本文将证明，对于各边平行于坐标轴的的平面剖分，的确存在着能够突破Chazelle和Liu所给出的下界的解法。二维分散层叠问题蕴含着十分丰富的结构，因此我们将对输入数据的不同情形进行分类讨论：

​		当G是一个树且$\pi$为树上的一条路径时，查询可以在线性空间和$O(\log n + |\pi| + min\{|\pi|\sqrt{\log n}, \alpha(n)\sqrt{|\pi|}\log n\})$的时间内完成，其中$\alpha$表示逆阿克曼函数。不仅如此，我们还可以证明此上界在两种情形下（min的取值）都是紧确的，至多只差一个逆阿克曼函数因子。

​		当G是一个图或者$\pi$是一个子图时，查询时间上界变为$O(\log n + |\pi|\sqrt{\log n})$并且这个上界是紧确的。

### 一些定义与前置结论

​		在介绍正文之前，先列出一些文章中会用到的定义、前置算法与结论。

**定义1：平面剖分及其复杂度**

​		所有边都是直线段的平面图，在下文中我们讨论的平面剖分默认是**轴对齐**的。平面剖分的复杂度定义为点、线、面的个数之和。

**结论1：点定位算法**

​		和一维有序集上的二分查找类似，二维平面图上的点定位算法能够在$O(\log n)$的时间内确定一个二维点$q$位于平面图的哪一个面上。其中$n$为平面图的复杂度，对于轴对齐的平面图，$n$与图中矩形的个数是同阶的。点定位算法需要$O(n)$的空间进行预处理。

**结论2：矩形定位（Rectangle Stabbing）算法**

​		先介绍比较简单的二维形式：

​		Rectangle Stabbing（以下简称RS）算法可以说是点定位算法的推广形式：在点定位中，查找是在一个平面图上进行的，平面图上各个区域（面）互不相交。而在RS算法中，我们的图只是由若干个轴对齐的矩形组成的，矩形之间可以有交也可以没有，总之可以以任意方式分布在平面上，RS算法能以$O(n)$的空间预处理这些矩形，对于询问$q$，能够在$O(\log n+t)$的时间内查找到所有包含点$q$的矩形。其中$n$表示平面上的矩形个数，$t$表示输出规模。

​		RS算法也有高维形式，有结论如下：对于d维RS问题，可以构造一个使用$O(nHlog^{d-2}n)$空间的数据结构，取得$O(\log n (\log n / log H)^{d-2}+t)$的查询时间复杂度，其中$H\geq 2$为任意待定参数，$t$为输出规模。

​		注意到RS算法也是输出多组符合要求的矩形，这和分散层叠的输出有几分相似。实际上，将$\pi$中所有结点对应的平面剖分叠在一起，然后再在这个混合图上建立RS数据结构，我们查询所得到的结果就是分散层叠的输出。在原文中，会经常对查询图的一部分建立RS结构。

**定义2：划分（cutting）与冲突列表（conflict list）**

​		一个复杂度为$n$的平面剖分$A$的$1/r$-**划分**，是一个复杂度为$O(r)$的平面剖分$C$，且$C$中任何一个面只与$A$中$O(n/r)$个面有交集。对于$C$中的任何一个面$f$，称$A$中与$f$有交集的面构成$f$的**冲突列表**，冲突列表的规模为$O(n/r)$。

**结论3：划分的构建**

​		给定一个轴对齐的平面剖分，复杂度为$n$，我们可以建立一个规模为$O(r)$的$1/r$-划分，$1\leq r\leq n$，满足：划分中每一个面（cell：后文或称为**区域**、**大矩形**）都为轴对齐的矩形，并且每一个面的冲突列表规模为$O(n/r)$。显然，维护划分及其冲突列表需要$O(n)$的空间。

​		划分是一个原文将要使用的一个重要工具，因为它能够将复杂度较高的平面剖分“简化”为一个复杂度较低的平面剖分，对于一个点$q$，如果我们能够确定$q$在后者的区域（cell），再在此cell的冲突列表上跑一个点定位算法，就能够确定$q$在前者的区域。这种将确定点的位置分成两个阶段的方法可以方便我们使用分治策略，也可以方便我们调整参数以平衡空间复杂度。

### 问题定义与文章主要脉络

​		原文对输入数据进行了极为详尽的分类讨论，大体框架是：先解决输入为树、沿路径查询的情况，然后用同样的思路将解法推广至输入为图、沿子图查询的情形。在输入为树得情形下，原文又对树高h作了讨论，其中$\frac {\log n} {2} < h \leq \frac {\log^2 n} {2}$的情形是最困难、解法又最漂亮的部分，下面将对其作主要介绍。

$\frac {\log n} {2} < h \leq \frac {\log^2 n} {2}$，问题描述与结论如下：

​		输入一个树，高为h，满足$\frac {\log n} {2} < h \leq \frac {\log^2 n} {2}$，并对每一个结点赋上一个各边平行于坐标轴的平面剖分，n表示这些平面剖分的复杂度之和。取定参数$c\geq 3$, 我们可以构造一个使用$O(n\alpha_c(n))$空间的数据结构，使得对于任意查询$(q, \pi)$，其中$q$为一个二维点，$\pi$为一个树上路径，且路径长度满足$\frac {\log n} {2} < |\pi| \leq \frac {\log^2 n} {2}$, 能够在$O(\sqrt{|\pi|}\log n)$的时间内输出路径 $\pi$ 上所有包含点q的平面区域。

​		下面**Lemma 4.3~6**将一步步实现这个数据结构。

​		这四个定理的主要脉络是：
​		L4.3将建立一个最基本的数据结构用于解决所有“根到叶路径”的查询，
​		L4.4将利用分治策略递归建立L4.3数据结构，得到一个类似于线段树的结构，以解决所有路径的查询，但空间复杂度不够优秀。
​		L4.5/6的目的是优化L4.4的空间，他们是这么做的：L4.6将以L4.4为基础建立递归数据结构（类似于从线段树实现树套树，见领域综述），它与L4.4的功能相同、查询时间一致，但是只需消耗线性空间，以达到我们最终的目标。而L4.5就是在严格描述这种递归数据结构是如何逐层实现的。

​		有必要提及原文的一个常用技巧：首先待定参数$r$，对每一个平面剖分$A_i$，设复杂度为$n_i$，做参数为$r/n_i$的划分，划分后会得到总数为$O(n_i/r)$的大矩形（cells），这些大矩形组成新的平面剖分$C_i$，它的规模为$O(n/r)$，比原先的总复杂度更小。其中每一个大矩形至多与原来$O(r)$个小矩形相交，这些小矩形共同组成了大矩形的冲突列表（conflict set），只需要用$O(n)$的空间就可以存储所有冲突列表。

​		于是我们可以先确定$q$在$C_i$中的位置，接着再于$C_i$中通过定位算法以$O(\log r)$的复杂度确定$q$的最终位置，最后只需要寻找$r$平衡总体的时间复杂度即可。这个过程甚至可以递归进行，这也是L4.6的直接思路。

### 算法及其上界证明

**Lemma 4.3 ** 构造了一个数据结构，能够解决当$\pi$为“根到叶”路径时的情形。

​		大致思路是将问题归约为三维RS问题，转化方式如下：

​		首先待定$r$，做划分，将所有结点上的平面剖分规模缩小至$O(n_i/r)$，额外花$O(n)$的空间记录冲突列表。

​		我们先像区间树（或线段树）一样为每个结点赋上一个区间$[l_i, r_i]$，然后扩充一个维度z，将每个结点上的平面剖分（缩减后）沿$z$维“拉伸”成三维柱体，且使柱体在$z$上的范围取$[l_i, r_i]$。

​		对于每一个查询$(q,\pi)$，其中 $q$ 为平面点，$\pi$ 为“根到叶”路径，考虑三维点 $q'$，在xy维度上与q相同，在z维上取$\pi$所对应的叶子结点上的区间中的某一值，这样一来，$q'$即蕴含了此次查询的全部信息，我们只需要获得所有包含$q'$的立方体，也就获得了在路径$\pi$上所有包含点$q$的面。

​		最后在所查询到的$O(\pi)$个面上逐一做定位算法即可。

于是问题就转化为建立一个三维RS数据结构，接下来证明复杂度：

引理：**Lemma 2.1. **对于d维RS问题，可以构造一个使用$O(nHlog^{d-2}n)$空间的数据结构，取得$O(\log n (\log n / log H)^{d-2}+t)$的查询时间复杂度，其中$H\geq 2$为任意待定参数。

​		注意到在划分后已经将平剖的总体复杂度缩减至$O(n/r)$，于是只需取$H=\frac{r}{log(n/r)}$, 即可保证线性空间，接下来将平衡三维RS与二维定位的查询时间：
$$
欲使\frac {\log^2 n} {\log (\frac{r}{log(n/r)})}=h\log r
$$
​		注意到$h=O(\log^2n)$，只需取$r$使得$\log r = \log(n / \sqrt h)$，即可使复杂度的上界为$O(\sqrt h \log n)=O(\sqrt{|\pi|}\log n)$





​		L4.4 将以 L4.3 中数据结构为基本单位，通过分治法构造一个更通用的数据结构，以处理对任意路径的查询，不再局限于“根到叶”路径。

**Lemma 4.4 **给定参数 $0<h1<h2\leq \frac{\log^2n}{2}$ ，查询类型为 $(q,  \pi)$，$\pi$为长度介于$h1$和$h2$的树上路径，其余条件同上，可以构建数据结构，使空间复杂度为$O(n\log(h_2/h_1))$，查询时间复杂度为$O(\sqrt{|\pi|}\log n)$.

​		首先注意到我们可以按高度将原树分解为若干个森林，使得除了一些边界情况外，森林中所有树高度均为$h_2$，于是任何一个查询路径至多只会经过森林中的两颗树。又注意到，对任何一条路径，可以取其最高点，将原路径分解为从最高点出发的左、右两个分支，不妨适当延长两条分支，使得各分支长度仍大于$h_1$。

​		其中，“适当延长”指将路径延长常数倍，以减少边界情况使其更易处理，在得到答案后，我们还可以在$O(|\pi|)=O(\sqrt{|\pi|}\log n)$的时间内筛掉多余答案。于是“适当延长”至多使时间复杂度乘上一个小常数因子。

​		通过上述讨论，不失一般性，我们可以假设树高$h$不超过$h_2$，且$\pi$的最高点即为其端点，且$h_1\leq |\pi|\leq h_2$。

​		接下来用分治策略建立数据结构：考虑所有高度为$h/2$的结点记为$v_1,v_2,...,v_m$，对应子树为$T_1, T_2,...,T_m$，去掉这些子树，剩余部分仍为一颗树，记为$T_0$，则$T_0,T_1,...,T_m$为原树的一个划分，且树高均不超过$h/2$，我们对所有$T_i$建立L4.3中的数据结构，接下来，如果$h/2\geq h_1$，就继续对每个$T_i$递归执行此过程，否则结束。这样分治总共进行了$O(\log(h2/h1))$层，每一层都会穷尽树上所有结点，于是空间复杂度为$O(n\log(h_2/h_1))$。

​		不难发现，对上述数据结构的查询与线段树的区间查询类同，在对线段树进行区间查询时，同一层至多被实际查询两次，也就是说，同一层的L4.3数据结构至多被调用两次，而单次查询所需时间为$O(\sqrt k \log n)$，$k$为该层对应$T_i$的高度，于是整体的时间复杂度为：
$$
\sum_{i=0}^\infty{\sqrt{\frac{|\pi|}{2^i}}\log n}=O(\sqrt{|\pi|}\log n)
$$
​		利用L4.4的结论，取$h_1=\frac {\log n }2,h_2=\frac{\log^2n}{2}$，已经能够得到在查询时间上符合要求的数据结构，但我们可以进一步压缩其空间复杂度。

​		接下来的L4.5是L4.6的一个准备，它将描述一种数据结构的递归构造过程，而L4.6将重复调用此过程，在L4.4的基础上建立一个只需要线性空间的目标数据结构。

​		L4.5所设计的数据结构与领域综述中介绍的“树套树”有几分相像——它们都是递归构造的。如果尚不了解树套树或者递归数据结构，可以先阅读领域综述中的相关内容以便更好地理解L4.5在做什么。

**Lemma 4.5** （严格表述）
		假设，对任意给定值$\Delta$，满足$\omega(1)\leq\Delta\leq\log n$，我们能够建立一个“基础”数据结构，能够在$Q_b(n)=O(\sqrt{|\pi|}\log n)$的时间内回答对于$(q,\pi)$的查询，其中$\pi$是一条长度介于$\frac{\log^2n}{2\Delta}$和$\frac{\log^2n}{2}$之间的路径。进一步假设它使用$S_b(\Delta,n)=O(nf(\Delta))$的空间，其中$f$为某一关于$\Delta$单调递增的函数，且$\lim_{\Delta\rightarrow\infty}f(\Delta)=\infty$。
		那么，对任意给定值$\Delta$，满足$\omega(1)\leq\Delta\leq\log n$，我们就能够建立一个“优化”数据结构，能够在$Q_b(n)+O(\sqrt{|\pi|}\log n)$的时间内回答对于$(q,\pi)$的查询，其中$\pi$是一条长度介于$\frac{\log^2n}{2\Delta}$和$\frac{\log^2n}{2}$之间的路径。进一步，它只使用$O(nf^*(\Delta))$的空间，其中$f^*$表示多重函数，即表示需要多少次调用$f$才能将函数值降到某个常值上。

证明：

​		我们先对每个平面剖分$A_i$作参数为$f(\Delta)/n_i$的划分，记划分后所得到的新平面剖分为$C_i$，并称这些$C_i$为“第1级划分”，每个$C_i$包含$O(n_i/f(\Delta))$个大矩形（cells），总计$n'=O(n/f(\Delta))$个。其中，每一个大矩形都有一个规模为$O(f(\Delta))$的冲突列表，我们在其上建立一个点定位（point location）数据结构，共需要$O(n)$的空间。

​		接下来开始递归：对第1级划分，即所有$C_i$，我们建立参数为$\Delta$的“基础”数据结构，记其为$\mathcal{A}_1$，$\mathcal{A}_1$所需要的空间为$S_b(\Delta,n')=O(n'f(\Delta))=O(n)$。

​		现在考虑查询$(q,\pi)$，记$\delta_1=\log(f(\Delta))$，则$\mathcal{A}_1$已经足以解决$\frac12\cdot(\frac{\log^2n}{\Delta})\leq|\pi|\leq\frac12\cdot(\frac{\log n}{\delta_1})^2$的情形。事实上，我们可以在$Q_b(n)$的时间内完成对$\mathcal{A}_1$的查询，即我们找到了路径$\pi$上所有包含点$q$的大矩形（cells），接下来，我们在每一个大矩形的冲突列表上跑一个点定位查询，对每一个结点要多花额外$O(\log(f(\Delta)))$的时间，因此，总查询时间为
$$
Q_b(n)+O(|\pi|\log(f(\Delta)))=Q_b(n)+O(\sqrt{|\pi|}\log n)
$$
（因为$|\pi|\leq\frac12\cdot(\frac{\log n}{\delta_1})^2=\frac12\cdot(\frac{\log n}{\log(f(\Delta))})^2$）。

​		接下来我们沿用这种思路，在保证线性空间的同时，将$|\pi|$的可行范围扩张。

​		对原平面剖分$A_i$作参数为$f(f(\Delta))/n_i$的划分，得到“第2级划分”，第二级划分总规模为$O(n/f(f(\Delta)))$，各个cell的冲突列表规模为$O(f(f(\Delta)))$。建立点定位数据结构所消耗空间仍为$O(n)$。接下来对第2级划分建立参数为$f(\Delta)$的“基础”数据结构，记为$\mathcal{A}_2$，所消耗空间为$S_b(f(\Delta),n/f(f(\Delta)))=O(n/f(f(\Delta))*f(f(\Delta))=O(n)$，仍是线性的。

​		现在考虑查询$(q,\pi)$，记$\delta_2=\log(f(f(\Delta)))$，则$\mathcal{A}_2$能够以$Q_b(n)+O(\sqrt{|\pi|}\log n)$的时间解决$\frac12\cdot(\frac{\log^2n}{f(\Delta)})\leq|\pi|\leq\frac12\cdot(\frac{\log n}{\delta_2})^2$的情形。

​		注意到$f(\Delta)\rightarrow\infty$，于是$\log^2(f(\Delta))<f(\Delta)$，故$\mathcal{A}_1,\mathcal{A}_2$总共能够解决的范围是$\frac12\cdot(\frac{\log^2n}{\Delta})\leq|\pi|\leq\frac12\cdot(\frac{\log n}{\delta_2})^2$。

​		我们可以继续这种操作，即每次将参数套一层$f$，这样经过$f^*(\Delta)$次操作后，$\delta$会降为一个常数，范围扩充完毕。

​		由于我们总共需要建立$f^*(\Delta)$个数据结构，每个所消耗的空间都为$O(n)$，而在查询时只需挑选其一，因此，空间复杂度为$O(nf^*(\Delta))$，时间复杂度为$Q_b(n)+O(\sqrt{|\pi|}\log n)$，证毕。

**Lemma 4.6** 基于上述结论，取定参数$c\geq 3$，可以构造一个使用$O(n\alpha_c(n))$空间的数据结构，取得$O(\sqrt{|\pi|}\log n)$的查询时间复杂度。或者，可以构造一个使用$O(n)$空间的数据结构，取得$O(\alpha(n)\sqrt{|\pi|}\log n)$的时间复杂度。其中$\alpha_c(n)$表示是第c级逆阿克曼函数，$\alpha(n)$表示逆阿克曼函数（见算法导论并查集均摊分析）。

​		在证明前，先约定一个常用函数：$log^{*(i)}$表示$log^{*(i-1)}$的多重函数，即$log^{*(i)}$表示需要调用多少次$\log^{*(i-1)}$才能把函数值降为2。
​		还有一个结论：$\log^{*(i)}(n)=\alpha_{i+2}(n)$.

证明：

​		由L4.4，设$h_1=\frac{\log n}{2},h_2=\frac{\log^2n}{2}$，我们可以得到一个使用$O(n\log\log n)$空间的数据结构以取得$O(\sqrt{|\pi|}\log n)$的查询时间。接下来，取$\Delta=\log n，f=\log n$，由L4.5，我们可以在保证同样的查询时间的条件下，将空间复杂度压缩至$O(n\log^*(\log n))=O(n\log^*n)$，我们还可以继续取$\Delta=\log n，f=\log^* n$，再次利用L4.5，可以进一步将空间复杂度压缩至$O(n\log^{**}(\log n))=O(n\log^{**}n)$，将这种操作不断进行下去，直到$\log^{*(i)}(n)\leq3$，总共需要$\alpha(n)$轮，注意到每做一轮压缩都要额外增加一次查询，于是空间复杂度为$O(n)$，而时间复杂度上升为$O(\alpha(n)\sqrt{|\pi|}\log n)$，或者我们可以在做了第$c$轮后就终止操作，此时空间复杂度为$O(n\log^{*(c)}(n))=O(n\alpha_{c+2}(n))$，时间复杂度仍为$O(\sqrt{|\pi|}\log n)$，证毕。

​		我们知道，$k$-级逆阿克曼函数以及逆阿克曼函数的增长极其缓慢，甚至在实际应用中，我们可以默认$\alpha(n)\leq4$，可以说，对于该问题，原文给出了一个在时间和空间上都很优秀的解法。

​		笔者发现，L4.6的证明在空间复杂度的估计上存在一处问题，不过对结果的影响至多只有一个阿克曼函数因子，将在“论文不足及改进”中说明。

## 论文不足及改进

### 一、关于L4.6的空间复杂度证明

**概述**

​		L4.6的第二个结论表明，在不断利用L4.5构造递归数据结构后，可以将空间消耗优化至$O(n)$，然而，经仔细分析，沿着L4.6原文的构造过程，最终达到的空间复杂度其实是$O(n\alpha(n))$，只不过原文在证明过程中隐式地忽略了逆阿克曼因子的影响，虽然逆阿克曼函数的增长极其缓慢，在实际中可以忽略，但在理论层面讲，$\alpha(n)$毕竟是一个能够趋于无穷的函数。接下来将阐述原文在哪里忽略了逆阿克曼函数因子，并给出一个对$O(n\alpha(n))$的空间复杂上界的严格证明。

**不足：**原文隐式地忽略了逆阿克曼因子

​		首先观察L4.5中描述的递归数据结构构造过程，“优化”数据结构所消耗的空间由两部分组成，一是维护各个划分的冲突列表所需的空间，为$O(nf^*(n))$，二是调用“基础”数据结构所需的空间，也为$O(nf^*(n))$，两者渐近相等。理论上，$O(nf^*(n))+O(nf^*(n))=O(nf^*(n))$，在L4.5中忽略一个常数因子没有问题。但是在L4.6的算法中会一层层地递归调用L4.5，如果我们调用的层数不为常数阶，那么所有被忽略的常数因子就会对总体的空间复杂度产生非常数阶的影响。在原文中的证明中既在前期忽略了常数因子，又在后来将L4.5递归调用了$\alpha(n)=\omega(1)$层，因而会对空间复杂度造成非常数阶的影响，于是从严格意义上来说，$O(n)$的空间并不成立。

**改进：**给出$O(n\alpha(n))$空间复杂度上界证明

​		首先，注意到，在L4.5~6中，**假如**我们只考虑建立L4.4中数据结构时所消耗的空间而忽略维护冲突列表所消耗的空间，那么“优化”数据结构的空间就将全部来自于“基础”数据结构，不会存在常数因子问题，因而原文的结论成立。为方便叙述，我们定义L4.6中任一递归数据结构的“权重”，表示它用来建立L4.4中数据结构所消耗的空间。这样一来，L4.5/6中所有的空间复杂度其实都等于“权重”。

​		接下来考虑L4.6构造过程中的递归树，假设构造共进行了$c$轮，那么我们得到的是一个高为$c$，所有叶子结点均在第$c$层的递归树。由上述权重的定义，任一非叶子结点的权重等于其所有孩子结点的权重之和。进而，任意结点的权重等于其对应子树中所有叶子结点的权重之和，于是每一层的权重和相等。

![image-20210113042422682](C:\Users\pc\AppData\Roaming\Typora\typora-user-images\image-20210113042422682.png)

​		注：L4.6的建立过程可以表示成一个递归树，其中建立每一层结点的空间代价均为$O(n)$，总空间复杂度为$O(n\alpha(n))$。

​		由L4.5过程可知，在调用任一内层数据结构$\mathcal{A}$时，维护冲突列表的空间开销与$\mathcal{A}$的权重渐近相等。于是建立任一层的空间代价就是该层的权重之和。由L4.6结论可知，当$c=\alpha(n)$时，各层结点权重之和均为$O(n)$，于是从下而上开辟任意一层结点时，都需要额外花费$O(n)$的空间，又递归树高为$\alpha(n)$，于是总体空间复杂度为$O(n\alpha(n))$，结论得证。

### 二、L4.1结论在特殊情况下的优化

**概述**

​		L4.1中给出了当$h\leq\frac{\log n}{2}$时的一个查询时间复杂度上界，为$O(\log n + |\pi|\sqrt{\log n})$，我们接下来将证明：在此条件下，若树上各个结点具有复杂度基本一致的平面剖分，则查询复杂度可以进一步优化为$O(\log n + |\pi|\log\log n)$，这显然是对原算法的一个极大的优化。

**不足**

​		原文在L4.1的证明中，采用了一种十分暴力的方法：对树上所有长度不超过$\log r$的路径进行预处理，并且在估计空间复杂度时，又假定了查找树为二叉树，而实际上的查找树未必是二叉的。不难发现这种预处理路径的方法必定会使同样的信息被多次维护，所以下面将从这一点入手来获得一种更高效的方法。

**改进**

​		往证：在L4.1条件下，若树上各个结点所附有的平面剖分具有渐近一致的复杂度，那么我们可以建立一个消耗$O(n)$空间的数据结构取得$O(\log n + |\pi|\log\log n)$的查询时间复杂度。

​		证明：我们先考虑如何预处理一条路径，再考虑需要预处理哪些路径。

​		首先，对于一条总复杂度为$n$的路径，我们在路径上**分块**：每$\log n$个连续结点为一个块，将块内所有矩形重叠在一起建立一个2维RS数据结构，总共消耗的空间为$O(n)$，对于任意查询$(q,\pi)$，其中$\pi$为该路径的一条子路径，为了找到$q$在$\pi$的各个结点上所属的矩形，只需在$|\pi|/\log n$个块上进行一次2维RS查询，所需时间为$|\pi|/\log n*\log n=O(|\pi|)$，另外对边界情况还需花$O(\log n)$的时间筛去多余答案，于是总时间复杂度为$O(\log n + |\pi|)$。

​		也就是说，对于一条复杂度为$n$的路径，可以用$O(n)$的空间进行预处理，进而能以$O(\log n + |\pi|)$的时间回答在其子路径上的查询。（1）

​		注意到，树上的任意一条路径均可被分成左、右两段，使得这两段都分别是某条“根到叶路径”的子路径，于是我们只需要预处理所有“根到叶”路径。那么预处理所有“根到叶”路径所需的空间是多少？设树上结点数$m$，则有$m\leq n$，故叶子结点个数，即根到叶路径个数不超过$m$，又树高$h\leq\log n$，于是所有根到叶路径所含结点个数不超过$m\log n$，而各个结点上的平面剖分的复杂度均渐近等于平均值$n/m$，故由上述结论，预处理所有根到叶路径的空间复杂度为$O(n\log n)$。

​		$O(n\log n)$的空间并不够优秀，不过我们可以先对所有结点作参数为$\log n/n_i$的划分，再对划分后的平面（总规模为$O(n/\log n)$）进行预处理，这样的空间消耗就是$O(n)$的了（至于对冲突列表的维护自然是线性的）。

​		最后考虑回答查询$(q,\pi)$的时间，首先要将$\pi$分为两部分，分别进行（1）中的子路径查询，所需时间为$O(\log n + |\pi|)$，这样我们获得了路径$\pi$上所有包含点$q$的区域（划分后），所以还需在这些区域上一一跑一遍点定位算法，由冲突列表的规模为$O(\log n)$，于是这一步所需的时间为$O(|\pi|\log \log n)$，总时间复杂度为$O(\log n + |\pi|\log\log n)$，证毕。

