#include<iostream>
#include<algorithm>
using namespace std;
typedef long long ll;

/*
0 < n <= 200 , 0 <= k <= 1000
1 <= ai <= 500 -- 是不是与状态有关
条件：分组，使每组极差之和不超过k
状态：学生分组情况，k
性质：排序不影响分组，故先将学生排序
1 2 3 5 6 8 9 11 16 18
此时，每组的极差为该组下标最大成员值 - 下标最小成员值
必有一组包含了最大成员

1 2 3，1
1 2 3
12 3
1 23

显然，应该先将学生按升序排序

考虑分组的分法，每个组都有一个左边界与右边界，但分法的细节过于复杂，*难以直接表示*
但是分法有没有等价的描述？
我们换个角度，其实，每个元素对应的状态组合而成就可以描述整体分法的状态

对于第i个元素，我们记j表示左边界下标小于i，且右边界下标大于等于i的集合个数
而所有集合的差值和，其实就可以用每个元素的 *贡献* 来算出

具体地，第i个元素的贡献是j * (a[i] - a[i - 1]) （1）
将上式对 i = 1 ~ n 求和，就得到了 所有集合的差值和

因此，对第i个元素，我们记k表示 对（1）式从1到i求和所得的结果
这样就可以定义状态空间(i, j, k), 在这个空间下，只考虑前i个数的方案总数为dp(i, j, k)

而我们最终的结果，显然，就是sum {dp(n, 1, k)}, k = 0, 1, ...,max

下面建立状态转移方程：
对于状态(i, j, k)，讨论元素i
1. 它自成一组，则dp(i + 1, j, k') += dp(i, j, k) 
2. 除1以外，它为某一集合的右边界，则dp(i + 1, j - 1, k') += dp(i, j, k)
3. 除1以外，它为某一集合的左边界，则dp(i + 1, j + 1, k') += dp(i, j, k)
4. 既非左边界也非右边界，则dp(i + 1, j, k') += dp(i, j, k)
在1、4中，k' = j * (a[i + 1] - a[i])
在2中，k' = (j - 1) * (a[i + 1] - a[i])
对3同理
此方法失败，除非你多开一个维度，但没必要

对状态加一些修改：
如果我们不添加尾状态与其集合的关系的话，就要重新考虑j的定义

考虑j：左边界小于等于i，且右边界大于i的集合个数
k的定义改为对 j * (a[i+1] - a[i]) 从1到i求和 
对于状态(i, j, k), 讨论元素i
1. 它自成一组，则dp(i, j, k) += dp(i - 1, j, k')
2. 除1外，它为某一集合的左边界，dp(i, j, k) += dp(i - 1, j - 1, k')
3. 除1外，它为某一集合的右边界，dp(i, j, k) += (j + 1) * dp(i - 1, j + 1, k')
4. 既非左边界也非右边界，dp(i, j, k) += j * dp(i - 1, j, k')
其中k = k' + j * (a[i + 1] - a[i])

方法二与方法一有一个重要的差别，就是方法二中从前推后时无需考虑前状态的过程状态（i与集合的关系）
但方法一是需要考虑的，所以理论上方法一要再加一维度才可行
*/
const int maxn = 300;
const int mod = 1e9 + 7;
int a[maxn];
ll dp[2][205][1005];
int main()
{
    int n, max;
    cin >> n >> max;
    for(int i = 1; i <= n; i++)
        scanf("%d", &a[i]);

    sort(a + 1, a + n + 1);
    a[n + 1] = a[n];
    // i = 1时，合法状态只有（1, 0, 0）和（1，1，a[2] - a[1]）
    dp[0][0][0] = 1;
    int pos = 0;
    for(int i = 1; i <= n; i++) {
        pos ^= 1;
        for(int j = 0; j <= n; j++) {
            for(int k = 0, kk; k <= max; k++) {
                if((kk = k - j * (a[i + 1] - a[i])) >= 0)
                    dp[pos][j][k]
                    = (dp[pos^1][j][kk]
                    + (j > 0 ? dp[pos^1][j - 1][kk] : 0) 
                    + (i > 1 && i < n ? j * dp[pos^1][j][kk] : 0) // 当j = 0时，1、4两种情况合并成一种
                    + (i > 1 ? (j + 1) * dp[pos^1][j + 1][kk] : 0)) % mod;
                else 
                    dp[pos][j][k] = 0;
            }
        }
    }
    int ans = 0;
    for(int k = 0; k <= max; k++) {
        ans = (dp[pos][0][k] + ans) % mod;
    }
    cout << ans << endl;
    
}